//
//  main.swift
//  ParseTLV_SwiftCmd
//
//  Created by Friedrich HAEUPL on 16.05.18.
//  Copyright Â© 2018 Friedrich HAEUPL. All rights reserved.
//

import Foundation

var text:String = String()

//: Playground - noun: a place where people can play
// some solutions used here:
// https://stackoverflow.com/questions/41082760/extracting-segments-of-data-object-in-swift-3
// https://oleb.net/blog/2015/09/swift-ranges-and-intervals/
// https://appventure.me/2016/07/15/swift3-nsdata-data/

extension Data {
    mutating func extract(tag: inout Data, length: inout Int, constructed: inout Bool) -> Data? {
        guard self.count > 3 else {
            return nil
        }
        
        var len:Int = 1
        
        // ---------- TAG ----------
        let tagnr = Int.init(self[0])
        
        constructed = ((tagnr & 0x20) == 0x20)
        
        if((tagnr & 0x1F) == 0x1F)
        { // see subsequent bytes
            len = 2
            for i in 1..<10 {
                if( (Int.init(self[i]) & 0x80) != 0x80)
                {
                    break
                }
                len += 1
            }
        }
        // Create a range based on the number of tag bytes
        var range = Range(0..<len)
        // Get a new copy of tag data
        tag = self.subdata(in: range)
        // Mutate data
        self.removeSubrange(range)
        
        // ---------- LENGTH ----------
        // Define the length of data to return
        length = Int.init(self[0])
        
        var numberOfBytes = 1
        
        if((length & 0x80) == 0x80){
            numberOfBytes = length & 0x7f
            if( numberOfBytes > 3 ){
                //
                return nil
            }
            
            length = 0
            for i in 1 ... numberOfBytes {
                length = length * 0x100 + Int.init(self[i])
            }
        }
        // Create a range based on the number of length bytes
        range = Range(0..<numberOfBytes)
        // Mutate data
        self.removeSubrange(range)
        
        // ---------- VALUE ----------
        // Create a range based on the length of data to return
        range = Range(0..<length)
        
        // Get a new copy of data
        let subData = self.subdata(in: range)
        
        // Mutate data
        self.removeSubrange(range)
        
        // Return the new copy of data
        return subData
    }
}

var data = Data(bytes:
    [   0xe1,0x35,
        0x9f,0x1e,0x08,0x31,0x36,0x30,0x32,0x31,0x34,0x33,0x37,
        0xef,0x12,
        0xdf,0x0d,0x08,0x4d,0x30,0x30,0x30,0x2d,0x4d,0x50,0x49,
        0xdf,0x7f,0x04,0x31,0x2d,0x32,0x32,
        0xef,0x14,
        0xdf,0x0d,0x0b,0x4d,0x30,0x30,0x30,0x2d,0x54,0x45,0x53,0x54,0x4f,0x53,
        0xdf,0x7f,0x03,0x36,0x2d,0x35
    ])

/*
 var data = Data(bytes:
 [   0x57,0x11,0x54,0x13,0x33,0x00,0x89,0x60,0x00,0x69,0xd2,0x51,0x22,0x26,0x01,0x23,0x40,0x91,0x72,
 0x50,0x0f,0x50,0x50,0x43,0x20,0x4d,0x43,0x44,0x20,0x30,0x36,0x20,0x76,0x32,0x20,0x33,
 0x5f,0x34,0x01,0x01,
 0x9f,0x06,0x07,0xa0,0x00,0x00,0x00,0x04,0x10,0x10,
 0x9f,0x07,0x02,0xff,0x00,
 0x9f,0x0d,0x05,0x00,0x00,0x00,0x00,0x00,
 0x9f,0x0e,0x05,0x00,0x00,0x00,0x00,0x00,
 0x9f,0x0f,0x05,0x00,0x00,0x00,0x00,0x00,
 0x5a,0x08,0x54,0x13,0x33,0x00,0x89,0x60,0x00,0x69,
 0x9f,0x26,0x08,0xb3,0x2b,0x76,0xcd,0x27,0x65,0x83,0x5e,
 0x82,0x02,0x58,0x80,
 0x9f,0x36,0x02,0x00,0x01,
 0x9f,0x27,0x01,0x80,
 0x84,0x07,0xa0,0x00,0x00,0x00,0x04,0x10,0x10,
 0x9f,0x10,0x12,0x01,0x10,0xa0,0x00,0x09,0x24,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,
 0x9f,0x02,0x06,0x00,0x00,0x00,0x00,0x67,0x67,
 0x9f,0x03,0x06,0x00,0x00,0x00,0x00,0x00,0x00,
 0x9f,0x09,0x02,0x00,0x02,
 0x9f,0x34,0x03,0x3f,0x00,0x01,
 0x9f,0x1e,0x08,0x36,0x43,0x41,0x30,0x30,0x31,0x32,0x37,
 0x9f,0x33,0x03,0x60,0x60,0x08,
 0x9f,0x1a,0x02,0x06,0x16,
 0x9f,0x35,0x01,0x22,
 0x95,0x05,0x80,0x00,0x80,0x80,0x00,
 0x5f,0x2a,0x02,0x09,0x85,
 0x9a,0x03,0x18,0x05,0x15,
 0x9c,0x01,0x00,
 0x9f,0x37,0x04,0xf0,0xf5,0x11,0x4c,
 0x8a,0x02,0x00,0x00,
 0x9f,0x39,0x01,0x07,
 0x9f,0x40,0x05,0x60,0x00,0xb0,0x10,0x01,
 0x4f,0x07,0xa0,0x00,0x00,0x00,0x04,0x10,0x10,
 0x8f,0x01,0xf1,
 0x9f,0x53,0x01,0x00,
 0x9f,0x34,0x03,0x3f,0x00,0x01
 ])
 */
func parseTLVStream(data: inout Data, level:Int) -> Int{
    
    var part: Data? = Data()
    var tag: Data? = Data()
    var constructed: Bool = false
    var length:Int = 0
    
    
    if data.count == 0{
        return 1
    }
    
    repeat {
        constructed = false
        part = data.extract(tag: &tag!, length: &length, constructed: &constructed)
        //print(part ?? "No Data")
        if part != nil {
            print("TAG = \(tag! as NSData)")
            print("LENGTH = \(length)")
            print("VALUE = \(part! as NSData)")
            print("Remaining \(data as NSData)")
            
            // --------------- display the value
            
            for i in 0 ..< level{
                text.append("    ")
            }
            text.append(" \(tag! as NSData) \(length) \(part! as NSData) \r")
            
            
            
            if constructed == true {
                print("is constructed")
                // part = data.extract(constructed: &constructed)
                parseTLVStream(data:&part!, level: level+1)
                print("Level = \(level)")
            }
            else{
                print("Level = \(level)")
            }
        }
    } while part != nil
    
    
    
    return 0
}

parseTLVStream(data:&data, level:0)
print("---------------------")
print("\(text)")






